#!/usr/bin/env python3
################################################################
# Copyright (c) 2021 Witalis Domitrz <witekdomitrz@gmail.com>
# AGPL License
################################################################


import contextlib
import itertools
import json
import multiprocessing
import select
import subprocess
import sys
from typing import Required, TypedDict


class Block(TypedDict, total=False):
    name: Required[str]
    full_text: str
    color: str


ALL_BLOCKS = {
    block["name"]: block
    for block in []
    # Button blocks
    + [
        Block(name="close", full_text="❌"),
        Block(name="editor", full_text="✍️"),
        Block(name="menu", full_text="🔍"),
        Block(name="terminal", full_text="📄"),
    ]
    # Multimedia controls
    + [
        Block(name="next_track", full_text="⏭️"),
        Block(name="pause", full_text="⏸️"),
        Block(name="play_pause", full_text="⏯️"),
        Block(name="play", full_text="▶️"),
        Block(name="previous_track", full_text="⏮️"),
        Block(name="stop", full_text="⏹️"),
    ]
}

# Config
BLOCKS_TO_ADD = [
    ALL_BLOCKS[name]
    for name in [
        "close",
        "editor",
        "menu",
        "terminal",
    ]
]


# Defining blocks
def run_command_background(cmd):
    return subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def run_command_blocking(cmd):
    return subprocess.run(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, check=False
    )


def media_blocks():
    try:
        playerctl_title_process = run_command_blocking(
            "playerctl metadata title".split()
        )
        playerctl_status_process = run_command_blocking("playerctl status".split())
    except FileNotFoundError:
        return []

    if (
        playerctl_title_process.returncode != 0
        or playerctl_status_process.returncode != 0
    ):
        return []

    title = playerctl_title_process.stdout.decode().strip()
    status = playerctl_status_process.stdout.decode().strip()
    control_icon = "⏸️" if status == "Playing" else "▶️"

    info_block = Block(
        name="media_info",
        full_text=f"{title} {control_icon}",
        color="#BBFFBB" if status == "Playing" else "#BBBBFF",
    )

    return [
        ALL_BLOCKS["previous_track"],
        info_block,
        ALL_BLOCKS["next_track"],
        ALL_BLOCKS["stop"],
    ]


def add_no_internet_info(old_blocks):
    def is_internet_block(block):
        return "name" in block and block["name"] in ["ipv6", "wireless", "ethernet"]

    internet_blocks = list(filter(is_internet_block, old_blocks))

    if len(internet_blocks) == 0:
        return old_blocks

    if any(map(lambda x: len(x["full_text"]) > 0, internet_blocks)):
        return old_blocks

    for i, old_block in enumerate(old_blocks):
        if is_internet_block(old_block):
            old_blocks[i]["full_text"] = "⛔"
            break

    return old_blocks


# Click handling
def process_blocks(old_blocks):
    return media_blocks() + add_no_internet_info(old_blocks) + BLOCKS_TO_ADD


REFRESH_STATUS_CMD = "killall -SIGUSR1 i3status".split()


def run_command_on_click(cmd, accepted_button=1, refresh=False):
    def helper(button, **_):
        if button != accepted_button:
            return
        if not refresh:
            run_command_background(cmd)
        else:
            run_command_blocking(cmd)
            run_command_background(REFRESH_STATUS_CMD)

    return helper


def handle_volume(button, **_):
    if button == 3:
        run_command_background("pavucontrol")
        return
    if button in [1, 2]:
        cmd = "pactl set-sink-mute @DEFAULT_SINK@ toggle".split()
    elif button in [4, 7]:
        cmd = "pactl set-sink-volume @DEFAULT_SINK@ +1%".split()
    elif button in [5, 6]:
        cmd = "pactl set-sink-volume @DEFAULT_SINK@ -1%".split()
    else:
        raise RuntimeError(f"Unknown button: {button}")
    run_command_blocking(cmd)
    run_command_background(REFRESH_STATUS_CMD)


BUTTONS = {
    # Just run a command
    **{
        name: run_command_on_click(cmd)
        for name, cmd in {
            "battery": "xfce4-power-manager-settings",
            "close": "i3-msg kill".split(),
            "cpu_temperature": "xfce4-taskmanager",
            "disk_info": "nautilus",
            "editor": "gtk-launch code".split(),
            "ethernet": "nm-connection-editor",
            "ipv6": "nm-connection-editor",
            "load": "xfce4-taskmanager",
            "menu": "gtk-launch run_menu".split(),
            "terminal": "i3-sensible-terminal",
            "time": "xdg-open https://calendar.google.com/".split(),
            "tztime": "xdg-open https://calendar.google.com/".split(),
            "wireless": "nm-connection-editor",
        }.items()
    },
    # Run a command and refresh i3bar
    **{
        name: run_command_on_click(cmd, refresh=True)
        for name, cmd in {
            "media_info": "playerctl play-pause".split(),
            "next_track": "playerctl next".split(),
            "pause": "playerctl pause".split(),
            "play_pause": "playerctl play-pause".split(),
            "play": "playerctl play".split(),
            "previous_track": "playerctl previous".split(),
            "stop": "playerctl stop".split(),
        }.items()
    },
    # Use custom functions
    **{
        "volume": handle_volume,
    },
}

# Execution
HEADER = {"version": 1, "click_events": True}
I3STATUS_COMMANDS = [
    "i3status",
]


def combine_read_sources(*read_sources):
    while True:
        ready_reads, _, _ = select.select(read_sources, [], [])
        for ready_read in ready_reads:
            yield ready_read.fileno(), ready_read.readline()


def process_i3status_output(i3status_output):
    i3status_output_str = bytes.decode(i3status_output).strip().strip(",")

    try:
        result = json.loads(i3status_output_str)
    except json.decoder.JSONDecodeError:
        return None

    if not isinstance(result, list):
        return None
    return result


def combine_i3status_outputs(*i3status_outputs):
    fileno_order = [output.fileno() for output in i3status_outputs]

    last_remembered_lists = {fileno: [] for fileno in fileno_order}
    for fileno, output in combine_read_sources(*i3status_outputs):
        result = process_i3status_output(output)
        if result is None:
            continue
        last_remembered_lists[fileno] = result

        yield sum([last_remembered_lists[fileno] for fileno in fileno_order], [])


def show_status_text():
    print(json.dumps(HEADER, separators=(",", ":")), flush=True)
    print("[", flush=True)

    with contextlib.ExitStack() as stack:
        i3status_processes = [
            stack.enter_context(
                subprocess.Popen(i3status_command, stdout=subprocess.PIPE)
            )
            for i3status_command in I3STATUS_COMMANDS
        ]

        for unprocessed_data in combine_i3status_outputs(
            *(i3status_process.stdout for i3status_process in i3status_processes)
        ):
            data = process_blocks(unprocessed_data)
            print(json.dumps(data, separators=(",", ":")) + ",", flush=True)

    print("]", flush=True)


# Click handing
def handle_click(line):
    data = json.loads(line.strip().strip(","))

    if "name" not in data:
        return
    name = data["name"]

    if name in BUTTONS:
        BUTTONS[name](**data)


def clicks_handler():
    for line in itertools.islice(sys.stdin, 1, None):
        multiprocessing.Process(target=handle_click, args=[line]).start()


def main():
    process = multiprocessing.Process(target=show_status_text)
    process.start()
    clicks_handler()
    process.join()


if __name__ == "__main__":
    main()
